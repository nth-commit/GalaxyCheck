using System.Text.Json;
using FluentAssertions;
using Xunit;
using static GalaxyCheck.Samples.EverythingIsSerializable.Events;

namespace GalaxyCheck.Samples.EverythingIsSerializable;

/**
 * Demonstrates how to pass "control data" through to properties using Xunit's DataAttributes, and when you might want to do that instead of
 * generating the value in the property itself.
 *
 *
 * Scenario:
 *
 * I have an event-driven system. Commands are sent into the system, and command handlers may emit events. Events are then handled by a separate
 * worker process, so events need to be serializable so they can be pushed into a queue service. It's not practical to write an end-to-end test
 * covering every event - we have over 100 events right now, and we're adding more all the time. Because of this, sometimes we push new events that
 * haven't had their serialization exercised end-to-end. Worse still, sometimes we modify an existing event and completely break a workflow in
 * production!
 *
 * I want to make sure that all events are serializable. And when we add a new event, I want that to be covered by a test without needing to
 * remember to do it.
 *
 * I can use a property for that!
 */
public class Tests
{
    private static readonly IEnumerable<Type> _eventTypes =
        typeof(IEvent).Assembly.GetTypes().Where(it => it.IsAssignableTo(typeof(IEvent)) && it.IsClass); // Get all event types by reflection

    /**
     * This is how properties are normally written. All variable values are generated, which means that any test-case generated by the property might
     * receive any of our events.
     *
     * This is fine for most properties. But in this case, we actually want a property foreach event - as the serialization of each event is a
     * distinct behaviour that we want to ensure is well-tested.
     *
     * Properties generate 100 tests by default, and the input to the property varies randomly. If we had more than 100 events, then it'd be
     * impossible for a single run of the test suite to test each event. Also, each event would not be exercised all that thoroughly.
     */
    [Property]
    public Property AllEventsAreSerializable()
    {
        var gen =
            from eventType in Gen.Element(_eventTypes) // Generate a random event type
            from ev in Gen.Create(eventType) // Then, generate a random instance of that event type
            select ev;

        return Property.ForAll(gen, event0 =>
        {
            var event1 = SerializeDeserialize(event0);
            event1.Should().BeEquivalentTo(event0);
        });
    }

    public static TheoryData<Type> EventTypesTheoryData => _eventTypes.ToTheoryData();

    /**
     * Alternatively, we can use "control data" to express our tests.
     *
     * This treats the "event type" as a control variable, and we can create a property foreach event type. Each property then generates 100 tests (by
     * default, but we mightn't need that many now!). This is similar to the relationship between Facts and Theories in Xunit - adding control data
     * (using MemberData, or InlineData) will multiply a property by each control value.
     *
     * As a bonus effect, each property that is created by this method are treated as individual "test-cases" in your test explorer. This means that
     * you can easily run a single test for a single event type, and you can see which event types are covered by your test suite.
     */
    [Property]
    [MemberData(nameof(EventTypesTheoryData))]
    public Property EventIsSerializable(Type eventType)
    {
        var gen = Gen.Create(eventType);

        return Property.ForAll(gen, event0 =>
        {
            var event1 = SerializeDeserialize(event0);
            event1.Should().BeEquivalentTo(event0);
        });
    }

    private static object? SerializeDeserialize(object value)
    {
        var str = JsonSerializer.Serialize(value);
        return JsonSerializer.Deserialize(str, value.GetType());
    }
}
